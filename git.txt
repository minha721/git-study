git 명령어

**원격 저장소 추가**
- git remote add <name> <url> - <name>은 등록명, <url>은 원격 저장소의 URL(git remote add origin <url>로 일단 쓰자)
- 콘솔의 경우 push나 pull은 실행 시에 원격 저장소명을 생략하면, origin이라는 이름의 원격 저장소를 사용한다. 이 때문에 원격 저장소에는 origin이라는 이름을 붙이는 것이 일반적

**commit/push 과정**
1) git status - git 관리 하에 있는 폴더의 작업트리와 인덱스 상태 확인(untracked files이 보일 것 -> 인덱스에 등록하면 추적 대상으로 등록 됨)
2) git add <파일명> - 파일을 인덱스에 등록하는 명령어(파일명 파라미터에 . 을 지정하면 모든 파일 인덱스에 등록, 여러 파일 한번에 지정하려면 한칸 띄어쓰기로 구분)
3) git commit -m <설명> - commit 명령어 실행해 커밋 진행
4) git push <repository> <refspec> - <repository>는 push 경로의 주소, <refspec>은 push 할 브랜치(git push origin master라고 일단 쓰자)

**clone**
- 원격 저장소의 파일을 복제해오는 것
- git clone <repository> <directory> - <repository>는 원격 저장소의 URL, <directory>는 복제대상의 폴더명

**pull**
- 원격 저장소의 내용을 내PC로 가져오는 것
- git pull <repository> <refspec> - <repository>는 pull 경로의 주소, <refspec>은 pull 할 브랜치(git pull origin master라고 일단 쓰자)

**clone vs pull**
- clone은 원격 서버 저장소를 로컬 머신에 복사, 주로 프로젝트를 처음 업로드할 때만 사용되고 그 후는 pull 하는 것이 좋다
- pull은 다른 변경 사항이 로컬 컴퓨터에 추가, 내가 하고 있던 프로젝트의 최근 변경 사항을 원할 때 pull 할 수 있다

**merge 수동으로**
내가 끌어온 저장소(A)가 최신 버전이 아닌 경우, 즉 내가 pull을 실행한 후 다른 사람이 push를 하여 원격 저장소를 업데이트(B) 해버린 경우는 그 이후 나의 push 요청(C)은 거부된다.
이 경우 병합(merge)이라는 작업을 진행하여 다른 사람의 업데이트 이력(B)을 내 저장소에도 갱신해야한다. 병합하지 않은 채로 이력을 덮어쓰게 되면 다른 사람이 push한 업데이트 내역(B)이 사라져 버리기 때문이다.

- 병합 기능은 git에서 변경한 부분을 자동으로 통합해 주는 기능이지만 원격 저장소와 로컬 저장소 양쪽에서 파일의 동일한 부분을 변경한 경우 두 변경 내용중 어느 쪽을 저장할 것인지 자동으로 판단할 수 없어 충돌이 발생하고 이 부분을 직접 수정해주어야 한다.
- 위의 A, B, C에서 내가 C를 하면 오류가 발생하며 push를 거부 당한다. 이 경우 나는 git pull origin master 명령을 통해 B부분을 가져 오는데 merge를 하던 중에 충돌이 발생했다는 메시지가 표시될 것이고 해당 파일을 열어서 확인을 하면 자동으로 병합되지 않은 부분이 다음과 같이 나타날 것이다.
<<<<<<<
로컬 저장소에서 변경된 내용
=====
원격 저장소에서 변경된 내용
>>>>>>>
안쪽 내용을 수정한 뒤 불필요한 행(<<<<<<<, ======, >>>>>>>)은 지우고 다시 커밋을 하면 된다.

**branch란**
- 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어주는 기능
- 메인 브랜치에서 각자 자신의 작업 전용 브랜치를 만들어 소스코드를 입력하고 메인 브랜치에 자신의 브랜치 변경 사항을 적용하고 Merge함으로써 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다.
- master branch : 일반적으로 통합 브랜치(언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치)로 저장소를 처음 만들었을 때 git에서 만들어주는 브랜치, master가 아닌 또 다른 새로운 브랜치를 만들어 그 브랜치를 사용할 때는 checkout 해야 한다.
- 토픽 브랜치 : 기능 추가나 버그 수정과 같은 여러 단위 작업을 위한 브랜치, 보통 통합 브랜치로부터 만들어 내며, 토픽 브랜치에서 특정 작업이 완료되면 다시 통합 브랜치에 병합하는 방식, 피처 브랜치라고 부르기도 함
- branch 만들기 : git branch <branchname>
- branch 목록 전체 확인 : git branch -> 이 때 앞 부분에 *이 붙어있는 것이 현재 선택된 브랜치
- branch 삭제 : git branch -d <branchname>

**branch 전환**
- 처음 git을 설치하면 master branch가 선택되어 있다. 현재 브랜치가 아닌 다른 브랜치에서 작업하고 싶을 때에는 checkout 명령어를 실행해 원하는 브랜치로 전환할 수 있다.
- checkout을 실행하면 브랜치 안에 있는 마지막 커밋 내용이 작업 트리에 펼쳐지고 브랜치가 전환 되었으므로 이 후에 실행한 커밋은 전환한 브랜치에 추가된다.
- head : 현재 사용 중인 브랜치의 선두 부분, 기본적으로 master의 선두 부분, head 이동시 사용하는 브랜치가 변경 됨
- ~숫자 : head 뒤에 붙여 몇 세대 앞의 커밋을 가리킬 수 있음
- ^ : 브랜치 병합에서 원본이 여러 개인 경우 몇번째 원본인지
- stash : 파일의 변경 내용을 일시적으로 기록해두는 영역으로 작업 트리와 인덱스 내에서 아직 커밋하지 않은 변경을 일시적으로 저장하고 나중에 불러와 원래의 브랜치나 다른 브랜치에 커밋할 수 있다
- stash 사용 : 커밋하지 않은 내용이 작업 트리에 남아 있을 때 다른 브랜치로 checkout하면 그 내용은 전환된 브랜치에서 commit 가능하다. 하지만 변경 내용 중에 전환된 브랜치에서도 변경이 되어 있는 경우 stash를 이용해 일시적으로 변경 내용을 다른 곳에 저장하여 충돌을 피하게 한 뒤 체크아웃을 해야한다.
- branch 변환 : git checkout <branchname>

**branch 통합**
- master 브랜치에서 분기하는 bugfix 브랜치가 있다고 가정
- merge 사용(fast-forward) : bugfix 브랜치를 병합할 때, master 브랜치 상태가 변경되어 있지 않으면 master 브랜치가 bugfix로 단순히 이동만 해도 bugfix 브랜치의 내용을 적용할 수 있다.
- merge 사용(non fast-forward) : bugfix 브랜치를 병합할 때, master 브랜치 상태가 변경되어 있다면 양쪽의 변경을 가져온 merge commit을 실행한다. 병합 완료 후, master 브랜치로 통합된 이력이 생긴다.
- rebase 사용 : bugfix 브랜치를 병합할 때, master 브랜치 상태가 변경되어 있다면 bugfix 브랜치의 이력이 master 브랜치 뒤로 이동하여 하나의 줄기로 이어지는데 bugfix와 master가 충돌하는 부분을 수정
- branch 병합 : git merge <commit>
- rebase 사용 : git rebase master -> 수정 -> 수정 후 commit이 아닌 git rebase --continue

**pull**
- pull을 실행하면 원격 저장소의 변경된 데이터를 가져올 수 있음
- 로컬 저장소의 모든 변경 사항이 반영되어 있는 상태에서 새로운 변경 사항이 있는 원격 저장소의 커밋을 로컬로 가져올 경우 단순히 fast-forward 병합이 이루어진다.
- 하지만 로컬 저장소의 master 브랜치에서도 변경 사항이 생긴 경우, 양 쪽의 변경을 통합해주어야 한다.

**fetch**
- 원격 저장소의 내용을 가져와 자동으로 병합 작업을 하는 pull과 달리 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않은 경우 사용
- fetch를 실행하면, 원격 저장소의 최신 이력을 확인할 수 있는데 이 때 가져온 최신 커밋 이력은 이름 없는 브랜치로 로컬에 가져온다. 이 브랜치는 'FETCH_HEAD'의 이름으로 체크아웃 할 수도 있다.
- 이 상태에서 원격 저장소의 내용을 로컬 저장소의 'master'에 통합하고 싶은 경우에는 'FETCH_HEAD' 브랜치를 merge하거나 다시 pull하면 된다.

**push**
- 로컬 저장소의 데이터를 원격 저장소로 push할 때에는 push한 브랜치가 fast-forward 병합 방식으로 처리 되도록 지정해 둘 필요가 있다.
- push하지 않으면 원격 저장소에 영향을 주지 않고 자신의 브랜치에서 자유롭게 작업가능하지만 이를 공유하려면 명시적으로 원격 저장소로 push 해야 한다.